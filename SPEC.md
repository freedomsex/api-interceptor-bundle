# Шаг назад

При использовании _ApiPlatform_ не предоставляет возможности использования стандартного цикла Симфони "от запроса к контроллеру". После поступления запроса "нас" сразу перебрасывает к описанию ресурса. Это удобно, однако во многих случаях крайне недостаточно. Разработчики ApiPlatform рекомендуют использовать прослушивать События порождаемые фреймворком для внедрения собственной логики при запросах ресурсов.

Формально, навешивание логики при помощи прослушивания Событий, это и есть способ работы Симфони. Разработчики Симфони создали конвейер Событий с целью абстракции разработки до уровня контроллеров, и доставки всех необходимых параметров запроса непосредственно в вызов конкретного метода контроллера автоматически связываемого с конкретным маршрутом (URL) запроса.

Авторы ApiPlatform отбрасывают разработчиков на несколько шагов назад. У нас уже нет привычного нам контроллера. Остаются только голые события фреймворка, использовать которые нам и рекомендуют авторы. Самостоятельно писать всю логику начиная от прослушивания самостоятельно выбранного События. Мне кажется это действительно большой шаг назад.


## Перехват запроса

Точно также, как это делает Симфони, я предлагаю перехватывать запрос используя стандартный функционал фреймворка. Это уже не контроллер. У нас нет "Ответа" на запрос. Мы перехватываем сам запрос от его поступления до момента обработки его бандлом _ApiPlatform_ или после. В этот момент мы можем выполнять любую необходимую нам бизнес логику. Также, мы можем получить доступ к данным передаваемым или обрабатываемым _ApiPlatform_ непосредственно.

Чаще всего нам нужно перехватить запрос в соответствии с методом запроса. Например при POST запросах нам важно прочитать данные и обработать их до обращения к базе данных. При GET запросах, возможно потребуется иметь актуальные данные из базы. Бывают ситуации, когда перехват и обработку необходимо произвести на нескольких этапах. Например, прервать выполнение запроса системой безопасности при его поступлении, до выполнения любых запросов к БД. Или продолжив обработку запроса, перехватить данные уже после их получения из базы. Выполнить некоторую аналитику на после завершения этого же запроса.

### Перехватчик

Это похоже на контроллер. Это имеет реализацию в других ФВ и ЯП. Я предлагаю выделять перехватчик реализовав `InterceptorInterface` и используя аннотацию  `@Intercept` - в ней указываются этап перехвата _$level_ и _$method_ запроса для перехвата. Есть возможность передать иные _$attributes_, но эта возможность мной не используется.

## Реализация

Во время всех используемых событий, смотреть определение класса ресурса на наличие аннотации `@Interceptor("App\Interceptor\SomeInterceptor")` и при её наличии, смотреть указанный класс Перехватчика на наличие аннотаций `@Intercept`. Когда такая имеется, сравнить уровень перехвата указанного в аннотации с уровнем "сработавшего" События и метода. При совпадении, выполнить метод перехватчика.
